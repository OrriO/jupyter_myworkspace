# 推荐系统-经典协同过滤理论基础实践

## 1.协同过滤推荐方法CF简介

* 协同过滤CF
  * 基于记忆的协同过滤
    * 用户相似度的推荐
    * 物品相似度推荐
    * UserCF用户协同过滤算法
    * ItemCF物品的协同过滤推荐算法
  * 基于模型的协同过滤
    * LFM(latent fator machine)隐藏因子的分解模型-----矩阵分解----Y=A\*B
    * ALS(Alternative least square) 交替最小二乘法
    * SVD分解---奇异值分解(无因变量)
    * SVD++(SVDPP)---加入因变量

## 2.U-U矩阵相似度推荐-Pearson

* pearson相关系数=====公式：协方差/标准差
* 算法部分：
  * 算法思想：通过Pearson相似度度量公式计算用户之间的相似度，构建相似度矩阵，实现简单的用户的推荐
  * 算法步骤：
    * 输入：用户行为数据---userid-itemid-rating
    * 输出：用户相似矩阵
    * 步骤
      * 1.计算各个用户之间同时购买商品的相似度
      * 2.当前用户和其他用户分别计算相似度，构建相似度矩阵
  * 算法优化
    * 需要考虑打分分值
    * 提出-UserCF-基于用户的协同过滤算法

## 3.V-V矩阵相似度推荐-cos

- pearson相关系数=====公式：协方差/标准差
- 算法部分：
  - 算法思想：通过修正后的余弦公式相似度度量公式计算用户之间的相似度，构建物品相似度矩阵，实现简单的用户的推荐
  - 算法步骤：
    - 输入：用户行为数据---userid-itemid-rating
    - 输出：物品相似矩阵
    - 步骤
      - 1.计算各个物品之间同时购买商品的相似度
      - 2.当前用户购买的物品和其他用户同时购买的商品计算相似度，构建相似度矩阵
  - 算法优化
    - 需要考虑打分分值
    - 提出-ItemCF-基于物品的协同过滤算法

## 4.U-V矩阵的相似度推荐

* 通过对用户和物品的隐式或显式打分数据通过UV矩阵形成，进入用于UserCF和ItemCF

## 5.基于用户的CF详解

* 算法思想：将UU矩阵得到的相似度矩阵作为输入，结合用户行为数据，构建用户对未知商品的打分，进行去重过滤排序得到最后的推荐结果
* 算法步骤：
  * 获取UU矩阵用户和用户之间的相似度
  * 将用户的其他用户之间的相似度与用户对商品的打分相乘得到用户对商品的综合评价得分
  * 对评价得分按照从大到小的顺序进行抽取TopN
  * 获得初始推荐结果
* 算法特点：
  * 在用户数量急剧增加的情况下，需要对比多个用户之间的相似度，算法性能出现瓶颈
* 算法使用场景：
  * 当物品数量较多的时候，可优先选择用户CF---UserCF

## 6.基于物品的CF详解

- 算法思想：将VV矩阵得到的相似度矩阵作为输入，结合用户行为数据，构建用户对未知商品的打分，进行去重过滤排序得到最后的推荐结果
- 算法步骤：
  - 获取VV矩阵物品和物品之间的相似度
  - 将用户购买的物品和其他物品之间的相似度与用户对商品的打分相乘得到用户对商品的综合评价得分
  - 对评价得分按照从大到小的顺序进行抽取TopN
  - 获得初始推荐结果
- 算法特点：
  - 在物品数量急剧增加的情况下，需要对比多个物品之间的相似度，算法性能出现瓶颈
- 算法使用场景：
  - 当用户数量较多的时候，可优先选择ItemCF

## 7.UserCF和ItemCF区别和联系

* UserCF基于用户的相似度推荐
  * 应用场景：用户数据量较少的或物品数据量较多的时候
  * 冷启动：新用户冷启动无法实时更新，物品的冷启动是需要在用户产生行为的情况下可以推荐新物品
  * 推荐理由：相似的用户也购买、浏览什么商品
* ItemCF基于物品的相似度推荐
  * 应用场景：物品的数据较少或用户数量较多的时候
  * 冷启动：物品冷启动，只有等物品相似度矩阵更新之后基于用户行为进行新物品推荐
  * 推荐理由：您购买的物品的相似物品
* 缺点：冷启动、马太效应

## 8.推荐算法实战协同过滤源码之UserCF分析

* UV矩阵-----VU矩阵(倒排)-------UU矩阵(相似度)
* 进行相似度计算
* P(u，i)=sum(sim（u，i）*Rate)
* 源码实战：
  * 数据集导入，切分数据集形成训练集和测试集
  * 定义UserBasedCF类，读入数据，整个逻辑处理
  * 定义用户相似度计算---定义倒排表---计算相似度权值
  * P=score*sim
  * 推荐：首先拿到K个用户，拿相似到K个用户的N个商品

## 9.推荐算法实战协同过滤源码之ItemCF分析

* UV矩阵---无序进行倒排表-----统计VV矩阵(物品和物品的相似度)
* 进行物品和物品的相似度计算---Jacard距离
* P(u，i=sum(i,j)*R（U,j）
* 源码实战：
  * 数据集导入，切分数据形成训练集和测试集
  * 定义ItemBaseCF类，读入数据，整个逻辑
  * 定义VV矩阵(无需倒排表即可完成VV矩阵统计)
  * P=score*sim
  * 拿到用户浏览商品的近K个最接近商品，从中选择M个偏好值较高的商品

## 10.基于相似度推荐源码实战

* 通过cos计算余弦相似度
* 导入用户和商品的数据，首先通过制表符进行分割，userid、itemid、rating
* 构建倒排表：构建UU矩阵---用cos相似度计算---将结果返回
* 计算推荐列表：通过用户的协同过滤算法得到每个商品的得分，给到最终推荐列表。

## 11.Mahout是什么 

* Mahout是机器学习库，集成了大部分机器学习算法，利用算法结合数据建立模型，Mahout是基于MR的机器学习框架，现在Mahout已经废弃了MR作为底层执行引擎，改为了Spark作为底层引擎，支持Scala语言。

## 12.Mahout能做什么 

* Mahout可以做推荐引擎
* Mahout可以实现分类
* Mahout可以实现聚类等场景

## 13.Mahout协同过滤算法 

* DataModel
  * 本地文件、JDBC\Mysql等介质中获取数据
* 相似度度量方法
  * SimlarityUser、SimlarityItem
* 最近邻
  * 最近的K个邻居
  * UserNeighborhood
* 推荐引擎Recommender
  * UserBaseRecomender
  * ItemBaseRecommender
* 推荐结果评价
  * rmse--根均方误差
  * 召回率、分类准确率等

## 14.Mahout协同过滤算法编程

* 大致流程：
  * 加载数据
  * 实现基于用户或基于物品的相似度计算
  * 实现用户的最近的K个邻居的查找
  * 通过UserCF和ItemCF类进行协同过滤推荐
  * 通过RMSE验证效果、使用prescition和recall共同查看性能
* Mahout提供了GenericItemBasedRecommender、GenericUserBasedRecommender
* 通过两个推荐方法可以将用户的协同过滤和物品的协同过滤通过推荐器进行加载推荐

## 15.基于Mahout混合推荐业务需求分析和数据准备

* 业务需求：
  * 24个推荐位
    * 1个硬广
    * 6个推荐位*4次=24个推荐位通过不同的模型进行推荐
* 数据：
  * 通过网络爬虫方式
  * 商品id、商品name、商品url、商品价格、商品图片
  * 假设有一个guyong用户在对应的121推荐位推荐商品

## 16.基于Mahout混合推荐业务功能实现分析和产品原型设计

* 功能实现
  * 数据来源：用户的cookies数据、点击流埋点日志中获取
  * 离线推荐：基于历史数据的协同过滤推荐、用户上一次浏览的记录基于物品的协同过滤、用户上一次浏览记录的基于内容的推荐
  * 实时推荐：基于物品和基于内容推荐24个商品
  * 对离线和实时的推荐商品需要进行排序、过滤、去重

## 17.基于Mahout混合推荐项目开发及补充

* 项目架构：
  * 数据平台：提供三种推荐引擎-基于用户CF、基于物品的CF、基于内容的推荐、用户画像
  * 结果和相似物品和相似用户存储：存储在Redis中，如存储和id=100相似的400个用户
  * 实时推荐：获取正在浏览商品的信息或用户信息，和已经存放在redis中的相似用户或相似商品的内容进行比对，得到实时推荐结果
  * 在得到初始的召回结果之后通过排序和过滤、补足等功能完成最终初始推荐结果
  * 存放在Redis中供前端去调用
* 代码：
  * 获取产品信息(通过网络爬虫)
  * 猜你喜欢推荐接口----实现接口
  * 猜你喜欢的主要流程---广告位和用户涉及
  * 通过固定的广告位进行推荐，绑定用户进行推荐
  * 根据业务规则或后台进行重复商品数据的去重
  * 初始数据进行商品推荐

## 18.基于模型的CF理解

* 基于模型的CF是为了解决基于记忆的CF需要大量使用内存进行相似度的计算，只需要借助于模型就可以直接将数据通过模型得到预测值，而不需要全部将数据放入内存进行计算，避免了因为内存不足或计算复杂度太高带来的影响。
* Y=A(m\*n)*B(n\*K)
* 简单理解：用户对电影的评分==用户对电影本身评分*电影本身具备特性评分
* LFM简称是：Latent Factor Machine 隐藏因子分析
  * 理解：通过上面的理解，将一个矩阵分解为两个具有具体业务场景的矩阵，但是在实际使用LFM模型中实际上矩阵的分解是不清楚具体的物理含义，因此，叫做隐藏因子。具体来讲上述的两个A矩阵和B矩阵可以使用随机数进行初始化，通过机器学习算法进一步学习得到最终评分。

## 19.基于LFM推荐算法

* 基于隐因子模型分解的方法
* 初始化分解后的矩阵A和B
* 构建损失函数sum(r(ij)-P\*Q.T)
* 求解损失函数最优解---关于P矩阵求解导数，关于Q矩阵求解导数
* 利用梯度下降法求解P和Q矩阵的最优解
* 得到最佳的P和Q导数的最优解，估计其他未知位置的数据，进行推荐
* LFM推荐可解析性很弱

## 20.补充知识点：梯度下降法

* 基于有一个损失函数(目标函数、误差函数)
* 求解函数最优解
  * 解析解
  * 最优解-----梯度下降法
* 梯度下降法====
  * 什么是梯度===
    * 梯度是方向导数最大值的方向，梯度的值是方向导数最大值的值
    * 源自于方向导数==
      * 源自于偏导数==
        * 源自于导数====
          * 源自于切线斜率====
  * 用于最优解求解
    * X(k+1)=X(K）-alpha\* df(梯度算子)
    * df就是求解的位置参数的导数

## 21.LFM总结

* Latent Factor Machine-隐因子模型
* Y=A\*B其中A和B是分解后的含有隐因子的矩阵
* 利用机器学习算法通过构建损失函数，结合梯度下降法达到求解A矩阵和B矩阵的最优解
* 通过A和B的最优解求解得到Y的预测值，根据预测值的大小进行排序，拿到TopN个商品进行相关联推荐

## 22.今日总结






